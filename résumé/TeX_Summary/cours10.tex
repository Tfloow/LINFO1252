\section{Cours 10}\label{cours-10}

\subsection{La m√©moire}\label{la-muxe9moire}

Acc√©der √† la m√©moire directement n'est pas une bonne solution car on
doit connaitre son organisation √† la compilation. Impossible car si on
passe de 2 Go de RAM √† 4 il faut tout recompiler !! On va virtualiser
tout √ßa

\subsubsection{La M√©moire Virtuelle}\label{la-muxe9moire-virtuelle}

On va devoir faire une traduction du virtuelle √† physique via le
\textbf{MMU} ou \textbf{Memory Management Unit} (qui est dans le
processeur).

\begin{figure}
\centering
\includegraphics{image-52.png}
\caption{MMU Simple}
\end{figure}

Ainsi on peut d√©coupler la taille et √©crire les adresses sur + de 32
bits.

On peut faire de la librairie partag√©e tr√®s facilement, on peut voir que
2 programmes pointes vers la m√™me zone de la RAM !

\paragraph{Avantages}\label{avantages}

On peut utiliser le stockage sur le disque pour mettre des objets
inutilis√©es de la RAM. C'est le principe de \textbf{\texttt{swap}}. Et
on peut faire vice-versa.

\subsubsection{Fonctionnement de la m√©moire
Virtuelle}\label{fonctionnement-de-la-muxe9moire-virtuelle}

La m√©moire a un acc√®s par \emph{adresse} et les SSD par \emph{secteur}.
La m√©moire virtuelle est divis√©e par \textbf{pages}. C'est une zone de
m√©moire \textbf{contigu√´} de taille 4 Ko (4096 octets (on peut v√©rifier
via \texttt{getpagesize()})).

On a toujours un nombre entier de pages. De plus, chaque segment (les 6)
occupe leurs propres pages.

Ainsi, les pages virtuelles peuvent √™tre plac√©es dans n'importe quelle
zone (\emph{frame}/cadre de page) de la m√©moire physique.

Adresse Virtuelle est compos√©e de:

\begin{itemize}
\tightlist
\item
  Num√©ro de la page
\item
  Offset sur cette page √† faire
\end{itemize}

Le MMU se charge de la traduction.

\begin{figure}
\centering
\includegraphics{image-53.png}
\caption{D√©coupage en page}
\end{figure}

\subsubsection{Mise en Oeuvre de la
Traduction}\label{mise-en-oeuvre-de-la-traduction}

Il doit avoir acc√®s √† l'allocation actuelle entre pages virtuelles et
cadres de pages physique. On va utiliser une table des pages:

\begin{itemize}
\tightlist
\item
  Tableau index√© par le num√©ro de page
\item
  Bit de validit√© si la page existe dans l'espace m√©moire du
  \emph{processus}
\item
  Si valide: ligne du tableau indique le lien vers le num√©ro de cadre de
  page.
\end{itemize}

\begin{figure}
\centering
\includegraphics{image-54.png}
\caption{Traduction}
\end{figure}

Chaque processus poss√®de donc sa \textbf{propre table des pages} (pas
pour le kernel). On a un registre sp√©cial qui contient l'adresse de base
en m√©moire de la table des pages du processus actuel (restaur√© √† chaque
r√©tablissement de contexte).

\paragraph{Exemple pour 2 processus}\label{exemple-pour-2-processus}

Si on a un syst√®me 8 bits (RAM maximum de 256) ce qui nous donne 16
cadres de pages de 16 octets chacun. On d√©cide d'avoir des adresses
virtuelles sur 6 bits donc un maximum de 64 octets par processus (chaque
processus va donc utiliser 4 pages --\textgreater{} 2 bits pour la page
4 pour l'offset).

Imaginons 2 processus \texttt{P1} et \texttt{P2} qui requiert 3 pages (2
pour leur text et 1 pour leur stack).

\begin{figure}
\centering
\includegraphics{image-55.png}
\caption{Exemple P1 et P2}
\end{figure}

On remarque que faire la traduction entre adresse physique et virtuelle
requiert 1 acc√®s en plus. On va donc mettre en \emph{cache} les
traductions souvent utilis√©es via un \textbf{TLB} ou \textbf{Translation
Lookaside Buffer} ce qui nous donne un fonctionnement de la sorte.

\begin{figure}
\centering
\includegraphics{image-56.png}
\caption{TLB hit et miss}
\end{figure}

\subsubsection{Protection des Pages}\label{protection-des-pages}

On peut encoder les droits d'une page sur 3 bits: \texttt{R}, \texttt{W}
et \texttt{X}. Si on essaye de faire une action invalide, on g√©n√®re
ainsi un trap qui passe la main au SE.

On peut retirer des droits √† une page via:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}\PreprocessorTok{ }

\DataTypeTok{int}\NormalTok{ mprotect}\OperatorTok{(}\DataTypeTok{const} \DataTypeTok{void} \OperatorTok{*}\NormalTok{addr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ len}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ prot}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Probl√®me du Swap}\label{probluxe8me-du-swap}

On a 2 fa√ßon de faire du swap (qui permet d'avoir plus de pages
virtuelles):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Partition de Swap:

  \begin{itemize}
  \tightlist
  \item
    ‚úÖ Rapide
  \item
    ‚ùå Portion du disque d√©di√©e
  \end{itemize}
\item
  Fichier de Swap:

  \begin{itemize}
  \tightlist
  \item
    ‚úÖ Flexible
  \item
    ‚ùå Performance moindre (fragmentation du fichier)
  \end{itemize}
\end{enumerate}

\paragraph{Fonctionnement par d√©faut d'un acc√®s √† une
page}\label{fonctionnement-par-duxe9faut-dun-accuxe8s-uxe0-une-page}

\begin{figure}
\centering
\includegraphics{image-57.png}
\caption{D√©fauts de page}
\end{figure}

\begin{figure}
\centering
\includegraphics{image-58.png}
\caption{Traitement d'un d√©faut de page}
\end{figure}

On va donc devoir rapatrier des pages du disque vers la m√©moire si on
constate un d√©faut de page (ou en cr√©er une nouvelle).

On va devoir aussi faire une politique de suppression des pages les plus
anciennes et des moins utilis√©es. Cela va suivre des crit√®res bien
pr√©cis:

\begin{itemize}
\tightlist
\item
  M√©tadonn√©es qui ne rajoutent pas de la lourdeur (utilis√©e des bits des
  pages non utilis√©s)
\item
  Ne pas supprimer des pages qui sont souvent utiliser ou va l'√™tre.
\end{itemize}

On va \textbf{√©viter} ces 2 politiques:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  FIFO: supprimer les pages les plus anciennes. Ne prend pas en compte
  le fait qu'on utilise activement une page
\item
  Conserver des statistiques sur les acc√®s: irr√©alistes et co√ªteux.
\end{enumerate}

On va utiliser le principe du \textbf{LRU} ou \textbf{Least Recently
Used} pour enlever la page utilis√©e en dernier. On va faire cela sans
compter le temps. On va tous les X cycles d'horloges checker 2 bits
sp√©cifiques:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Dirty bit: page modifi√©e ? \emph{page modifi√©e et √† mettre √† jour sur
  le disque}
\item
  Reference bit: page utilis√©e ? \emph{page acc√©d√©e r√©cemment}
\end{enumerate}

\begin{figure}
\centering
\includegraphics{image-60.png}
\caption{Format complet d'une entr√©e de la table des pages}
\end{figure}

Apr√®s chaque check, le SE va mettre ces 2 bits √† 0. On va supprimer en
premier les pages qui sont \texttt{00} et \texttt{01} car elles ne sont
pas acc√©d√©es.

\subsubsection{Fichiers Mapp√©s en
M√©moire}\label{fichiers-mappuxe9s-en-muxe9moire}

On peut mapper le contenu d'un fichier dans la m√©moire pour avoir plus
simple √† le manipuler (üëÄ oui
\href{https://media.discordapp.net/attachments/517720163223601155/1113851521029910569/GOODBOOOOOI.gif}{@Hokkaydo})
via cet appel syst√®me qui nous renvoie un pointeur vers la zone mapp√©e
ou un \texttt{MAP\_FAILED}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}\PreprocessorTok{ }

\DataTypeTok{void} \OperatorTok{*}\NormalTok{mmap}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{addr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ length}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ prot}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ flags}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ fd}\OperatorTok{,}\NormalTok{ off\_t offset}\OperatorTok{);}
\CommentTok{/*}
\CommentTok{* addr:     o√π on veut mapper, G√©n√©ralement NULL}
\CommentTok{* length:   longueur de la zone du fichier √† mapper}
\CommentTok{* prot:     permission (R/W/X)}
\CommentTok{* flags:    mapping priv√© (MAP\_PRIVATE) ou partag√© entre processus (MAP\_SHARED)}
\CommentTok{* fs:       descripteur du fichier}
\CommentTok{* offset:   o√π on veut d√©marrer √† mapper}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics{image-61.png}
\caption{Mapping en M√©moire}
\end{figure}

\paragraph{Appels Syst√®mes
Associ√©s}\label{appels-systuxe8mes-associuxe9s}

On peut forcer l'√©criture sur le disque (m√™me id√©e de buffer que pour
\texttt{printf}):

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}\PreprocessorTok{ }

\DataTypeTok{int}\NormalTok{ msync}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{addr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ length}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ flags}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Supprimer tout le mapping ou une partie

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}sys/mman.h\textgreater{}}\PreprocessorTok{ }

\DataTypeTok{int}\NormalTok{ munmap}\OperatorTok{(}\DataTypeTok{void} \OperatorTok{*}\NormalTok{addr}\OperatorTok{,} \DataTypeTok{size\_t}\NormalTok{ length}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{M√©moire partag√©e}\label{muxe9moire-partaguxe9e}

Quand on a plusieurs threads, la table des pages est copi√©e pour tous
les segments \textbf{sauf le Stack}.

On peut faire de la communication entre processus via de la m√©moire
partag√©e. Il faut que les entr√©es de la table des pages des deux
processus pointent vers les m√™mes frames physiques.

\paragraph{Gestion de la m√©moire
partag√©e}\label{gestion-de-la-muxe9moire-partaguxe9e}

\begin{longtable}[]{@{}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2478}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.4696}}
  >{\centering\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2826}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\centering
Fonction
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Param√®tre
\end{minipage} & \begin{minipage}[b]{\linewidth}\centering
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{int\ shmget(key\_t,\ key,\ size\_t\ size,\ int\ shmflg)} &
\texttt{key}: une cl√©. \texttt{size}: taille de page. \texttt{shmflg}:
on le met √† \texttt{IPC\_CREAT} pour cr√©er sinon obtenir un acc√®s. &
cr√©e ou obtient l'acc√®s √† un segment de m√©moire partag√©e \\
\texttt{void\ *shmat(int\ shmid,\ const\ void\ *shmaddr,\ int\ shmflg)}
& \texttt{shmid}: id de la page qu'on a obtenu. \texttt{shmaddr}: mis √†
\texttt{NULL}. \texttt{shmflg}: mis √† 0. & Pour attacher la page
partag√©e dans l'espace m√©moire du processus \\
\texttt{int\ shmdt(const\ void\ *shmaddr)} & \texttt{shmaddr}: l'adresse
retourn√©e par \texttt{shmat}. & Pour d√©tacher la page \\
\end{longtable}

Il faut faire attention √† ce que la m√©moire soit bien attach√©e pour les
deux processus. On va soit:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  √©viter d'utiliser des pointeurs (sinon il ne pointe pas vers les m√™mes
  choses dans le processus)
\item
  stocker les adresses relatives au d√©but de la zone m√©moire partag√©e
\end{enumerate}

\paragraph{Destruction des segments
partag√©s}\label{destruction-des-segments-partaguxe9s}

Les segments partag√©es vont continuer √† exister m√™me √† la terminaison du
processus cr√©ateur. On utilise \texttt{shmctl} pour supprimer un
segment. La suppression se fera au dernier \texttt{shmdt}.

\paragraph{Librairie partag√©e}\label{librairie-partaguxe9e}

La zone m√©moire li√©e aux librairies partag√©es se trouvent entre le stack
et le heap et sera en \texttt{.so}.

\begin{figure}
\centering
\includegraphics{image-62.png}
\caption{Espace m√©moire du processus}
\end{figure}

\subsubsection{\texorpdfstring{Fonctionnement de \texttt{fork} et
\texttt{exec}}{Fonctionnement de fork et exec}}\label{fonctionnement-de-fork-et-exec}

En faisant un \texttt{fork} on va faire une copie de la table des pages
en mode read pour le segment text sinon en mode √©criture, il faut
r√©aliser une isolation le \textbf{Copy-on-Write}.

\paragraph{Copy-on-Write}\label{copy-on-write}

Les pages sont d√©clar√©es en \emph{read-only} donc essayer d'√©crire va
g√©n√©rer un trap. Le SE va v√©rifier si l'acc√®s interdit est pour une page
r√©ellement en √©criture. Si c'est le cas:

\begin{itemize}
\tightlist
\item
  La page est dupliqu√©e vers une nouvelle page
\item
  Table des pages mise √† jour pour pointer vers cette copie
\item
  On red√©marre l'instruction qui a g√©n√©r√©e l'erreur
\end{itemize}

\begin{figure}
\centering
\includegraphics{image-63.png}
\caption{Copy-on-Write: apr√®s}
\end{figure}
